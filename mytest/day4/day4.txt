树  一对多的结构
特征
1 有且只有一个根节点
2 每个节点可以有0个或多个分支，且这些分支互不相交

概念：
前趋和后继：每个节点只能有一个前趋，可以有多个后继。根节点没有前趋

子树 ： 以一个节点的子节点为根节点的树称为这个节点的子树


度数： 几个节点的分支（后继个数）称为这个节点的度数。一棵树的度数为这个树中节点的最大度数


叶子节点：度数为0的节点

分支节点

父节点   子节点  兄弟节点

路径  边数 

层数

高度，深度

森林


树状模型

逻辑 ： 树  层次   -----》一对多

存储 ：通常不会采取顺序存储，因为浪费了大量的空间
　　　　
　　　　链式存储　引入了大量的指针　，在运算上非常的不方便。如果度数差距
　　　　较大也会浪费一定的空间

采用组合存储的方式

二叉树　：每个节点至多有两个子节点的树我们称之为二叉树

检索遍历，查找，加密，碰撞实验，情景选择


二叉树严格的区分左孩子和右孩子

二叉树第i（i≥1）层上的节点最多为2＾（i-1）个节点。
深度为k（k≥1）的二叉树最多有2＾k－1个节点。
　　　　
满二叉树
完全二叉树　

二叉树的数据模型

逻辑　：　树状

存储　：　顺序存储比较适合满二叉树或者完全二叉树　（平衡二叉树）

　　　　　链式存储是比较常用的存储方式

一颗普通的树转换为二叉树

原来的第一个孩子作为左孩子，原来紧邻的兄弟节点作为右孩子。

将其他的边断开，形成一个二叉树

运算：遍历　不重复的访问所有节点

先序遍历　（先根遍历）：　先访问根节点　然后左子树　然后右子树
中序遍历　　　　　　　：　左－－－－根－－－－右
后序遍历　　　　　　　：　左－－－－右－－－－根


先序中序或者后序中序可以唯一确定一颗二叉树。


数据模型

typedef  struct  node_t;		 /*定义二叉树节点的内部结构*/
{　　data_t data ; 		　　　　/*数据域*/	
　　struct node_t *lchild ,*rchild ; 	/*指向左孩子和右孩子的指针*/
} bitree_t ; 


权　（权值）：一个节点的有属性的值

带权路径长度　：　指的是指从根节点到该节点的路径长度与该节点权值的乘积　



















